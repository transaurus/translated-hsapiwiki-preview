# 基本構文

ここでは、petrichorian hopscript（tri-angleのhtn例に基づく）の経験に基づいた、言語の基本構文に関する大まかなアイデアを説明します。ここで説明する構文は、基本的にpetrichorian hopscriptを改良したものです。不明な点があれば、例を要求してください。

特定の場所で許可される構文のタイプと値は、その場所が属する「コンテキスト」に基づきます。

ファイルの最上部から始めて、トップレベルのコンテキストにいます。したがって、カスタムブロック、シーン、またはオブジェクト（これらは最初のシーンに配置されます）を定義できますが、ルールやメソッドブロックは定義できません。

## 構文規則

### コンテキスト変更行

コンテキストを変更する方法の1つは、コンテキスト変更行を使用することです。これらの行は、ウェブエクスプローラーのエディタでコンテナを持つもの（シーン、ルール、条件ブロックなど）とほぼ同じです。

一般的に、これらは以下のいずれかの形式です：
`<定義するもののタイプ> <必須の空白> <定義するものの名前> [オプションパラメータ]:`
またはコンテナブロック：
`<ブロック名> [オプションパラメータ]:`
`check_once_if`などのコンテナブロックは明らかに2番目のオプションを使用しますが、それ以外のほとんどは1番目の形式に近いです。例：
`check_once_if 7 == 7:`
^^ 単一のラベルなしパラメータリストでは括弧がオプションであることに注意

`repeat_forever:`
`Custom_block do_something(argument: "デフォルト値", arg2: 0):`
^^ カスタムブロックに関する詳細は後述
`Custom_rule ui_object:`
`Custom_rule make_a_grid(width: 5, height: 7):`
`Scene scene_1:`
`bear rawrbear(x_position: 512, y_position: 384, resize_scale: 2):`
`bird bird:`

これらの各行は、コンテキストを変更するだけでなく、異なる動作をします。例えば、`Custom_block go_to_center:`という行は：

1. `go_to_center`というカスタムブロックを定義します（既に存在する場合はエラーになります）。
2. カスタムブロックを追加できるコンテキスト（例：アビリティ）であれば、新しいカスタムブロックへの参照を追加します。
3. カスタムブロックが使用するアビリティのコンテキストに変更します。

この方法でコンテキストが変更された後、次の行は1レベルインデントされ、新しいコンテキストを使用します。前のコンテキストに戻るには、1レベルアンインデントします。例：

```hopscript
Custom_block go_to_center:                                 # <- Top level context
	set_position(to_x: Game.width / 2, y: Game.height / 2) # <- Ability for go_to_center context
Scene game:                                                # <- Top level context
	text petrichor(text: "🐠"):                            # <- Scene game context
		message = "hello!"                                 # <- Object petrichor context
		When game_starts:                                  # <- Object petrichor context
			show_popup(message: message)                   # <- Ability for when game starts rule context
	bird bird_grid:                                        # <- Scene game context
		Custom_rule make_a_grid(width: 5, height: 5)       # <- Object bird context (notice that without the `:` at the end, this is just a reference to the custom rule)
```

### パラメータ

コンテキストを変更する別の方法は、パラメータを使用することです。これは行の一部のみに適用されます。

ブロックにラベルのない単一のパラメータしかない場合（例：`check_once_if`）、最終値を単独で記述できます。それ以外の場合は、パラメータを括弧内に記述する必要があります。
括弧内は、`<パラメータラベル>: <値>`のカンマ区切りリスト、またはパラメータにラベルがない場合は値のみです。

値は任意の式（数学ブロック、条件ブロック、文字列リテラルなど）にできます。一部のコンテキストではこれがさらに制限される場合があります。

### カスタムブロックとルール

hopscriptでは、カスタムブロックとルールは特別な存在です。シーンやオブジェクトとは異なり、定義しても必ずしも使用されるわけではありません。トップレベルで定義すると、単に利用可能になるだけです。トップレベルのコンテキストで定義された場合、定義内のパラメータはデフォルト値のみであり、リテラル値でなければなりません（式は不可）。ただし、参照可能な場所で定義された場合、定義は参照としても機能し、パラメータは式を受け入れます。hopscriptの開発者として、式で定義された場合のパラメータのデフォルト値の扱いを決定する必要があります。これはあまり重要ではなく、デフォルトを`0`にするのが妥当だと思います。

また、定義された場所とは異なる場所で使用するには、以下のように参照します:
`Custom_block <名前> [オプションパラメータ]`
カスタムルールも同様ですが、`block`の代わりに`rule`を使用します。パラメータは、カスタムブロック/ルールがパラメータなしで定義された場合にのみオプションです。

### 変数

変数は`<スコープ>.<変数名>`の形式を取るか、曖昧でない場合は変数名のみで指定できます。スコープが指定されていない場合、`Local`と見なされます。変数名は文字列リテラルにすることもできますが、その場合、変数がローカルであってもスコープを指定する必要があります。

特性（オレンジ色のブロック、例えば不可視性(%)など）は変数と同様に扱われます。特性と同じ名前の変数を持ちたい場合、その名前は文字列リテラルにする必要があります。例えば、`Self."Width"`は「Width」という名前のセルフ変数であり、`Self.width`は特性`width`を指します。より良い方法の提案は大歓迎です。
ベースHopscriptで可能なスコープは以下の通りです:
`Game` – ゲーム変数
`Self` – 自身を参照するオブジェクト変数
`Original_object` – オリジナルオブジェクトを参照するオブジェクト変数
`Local` – ローカル変数
`User` – ユーザー変数
定義されたオブジェクト名 – そのオブジェクトを参照するオブジェクト変数
`Scenes` – 変数名として提供されたシーン名へのシーン参照。シーン参照を受け入れるブロックでのみ有効。ここでは変数も使用できるため必要です。また、特別な`Scenes.Next`、`Scenes.Previous`なども含みます。
拡張機能は独自のスコープを定義できる必要があります。詳細は拡張機能セクションで説明します。

### ブロック

ブロックにはいくつかの形式があります: 式ブロックとメソッドブロックです。
どちらも同じ形式を取りますが、使用できるコンテキストが異なります。式ブロックはパラメータ内で使用し、メソッドブロックはアビリティ内で使用します。
`<ブロック名> [オプションパラメータ]`
パラメータは、ブロックがパラメータを持たない場合にのみオプションです。
コンテナブロックの場合、メソッドブロックでなければならず、行末に`:`が必要です。これによりコンテキスト変更行になります。

### 二項演算子

特定のコンテキストで特定のブロックの短縮形として定義できる二項演算子があります。例えば、アビリティコンテキストでは、`=`二項演算子は`set(_:, to:)`ブロックの短縮形ですが、式コンテキストでは`equals`ブロックの短縮形になります。
可能な二項演算子は以下の通りです:
`=`, `-`, `/`, `*`, `+`, `^`, `!=`, `<=`, `>=`, `<`, `>`, `%`, `matches`, `and`, `or`
最後の3つは前後に空白が必要ですが、それ以外は空白がオプションです。

### 大文字化

Hopscript固有のものはCapital_snake_case（大文字スネークケース）にする必要があります。Hopscotchデータから直接来るもの、例えばブロック名/パラメータラベル、オブジェクトタイプ名などは通常のsnake_case（スネークケース）です。通常のsnake_caseはそれ以外の場合、ユーザー定義名に予約されています。

### コメント

コメントは`#`で始まり、行の残りがコメントになります。どのコンテキストでも使用できます。

### 空白

空白はほぼどこでも受け入れられ、無視されますが、時々必要です。例えば、以下の例は同じように解釈されます:
`set_position(to_x: Game.width / 2, y: Game.height / 2)`
`set_position   (to_x   :Game.width/   2,y:Game.height/2      )`

### 可能なコンテキスト

ベースHopscriptで可能なコンテキストは以下の通りです:

- トップレベル: 各ファイルの開始コンテキスト。カスタムブロック/ルール定義、シーン定義、インポート文、オブジェクト定義が可能。オブジェクトがトップレベルで定義された場合、その所属シーンはプロジェクトの最初のシーンとなる。実装は非常に単純ではないが、難しいものではない。
- シーン: シーン定義後のコンテキスト。オブジェクト定義が可能。
- オブジェクト: オブジェクトまたはカスタムルール定義後のコンテキスト。ルールやカスタムルールが定義/参照されていない場合、変数設定ブロック、カスタムルール参照/定義、ルール定義が可能。最初のルール/カスタムルール以降は変数設定ブロックは許可されない。
- アビリティ: カスタムブロック定義、ルール定義、またはコンテナーブロック定義後のコンテキスト。メソッドブロック、カスタムブロック参照/定義が可能。
- パラメーター: 前述のパラメーターセクションを参照。
- 式: パラメーター内

### 名前の制限

名前には、コンパイラが混乱する可能性のある文字を除き、任意の文字を含めることができる。現在考えられる禁止文字は以下の通り:

- 空白文字全般
- &num;
- (
- )
- =
- "
- ,
- /
- [
- ]
- :
- \-
- &plus;
- &ast;
- %
- ^
- &lt;
- &gt;

名前の最初の文字には追加の制限があり、名前の途中では許可される文字もある。これらは:

- 数字全般
- アンダースコア (\_)

### ブロックのオーバーロード

クローン作成（オプションパラメーターあり）や入力保存（ae modで追加パラメーターあり）などの場合、同じ名前で異なるパラメーターを持つブロックが有用である。これは許可されているが、ユーザー定義のカスタムブロック/ルールでは許可されない。これはHopscotchの動作と一致する。

### この構文に含まれていない必要機能

`When is_tapped Self:` は「自分がタップされた時」を表現する方法である。これは `When (Self) is_tapped` のような形式であるべき。

## ホップスコッチ化

以下のセクションでは、この構文がHopscotchコードにどのようにトランスパイルされるか（「ホップスコッチ化」と呼ぶ）を説明する。

ホップスコッチ化時には、非アドバンストモードのHopscotchにおける各ブロックの定義を含むファイルが暗黙的にインポートされる。この動作の詳細については、拡張機能セクションを参照。

### 名前のホップスコッチ化

名前はスネーク*ケースであると仮定してホップスコッチ化される。`*`文字で単語に分割され、最初の単語の最初の文字が大文字化された後、単語はスペースで結合される。

### コメントのホップスコッチ化

HopscriptはHopscotchよりも多くの場所でコメントを許可する。Hopscotchが許可する場所のコメントは直接含まれる。コメントが許可された場所にある行末のコメント（例: `repeat_forever: # メインループ`）は、コードの動作に影響しない場合に限り、行の残りのホップスコッチ化前に含まれる。合理的に最終プロジェクトに含められないコメントは削除される。

### マルチファイルプロジェクト

Hopscriptではマルチファイルプロジェクトが可能。他のファイルのコードを含めるには、トップレベルコンテキストで以下のような文を含める:
`Import "<現在のファイルからの相対パス>"`
引用符を省略して標準ライブラリのようなファイルをインポートすることも可能。例: アドバンストモード機能を使用する場合、`Import advanced.hopscript`。これはアドバンストモード、秘密のブロック、aeのmodのような一般的なmod、またはブーリアンのような便利な機能/Hopscript拡張に使用できる。
直接現在のファイルにインポートされたもののみを参照可能。
つまり、ファイルAがファイルBをインポートし、ファイルBがファイルCをインポートしている場合、ファイルAはファイルBで定義されたカスタムブロックは使用できるが、ファイルCのものは使用できない。
ただし、名前の重複に関する制限はプロジェクト全体に適用される。